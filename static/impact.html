<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Meteor Impact</title>
  <style>
    body { margin:0; font-family: system-ui, sans-serif; }
    #ui { position: fixed; right: 12px; top: 12px; background:#fff; padding:12px; border:1px solid #ddd; border-radius:8px; }
    label { display:block; margin:6px 0 2px; }
    input { width: 180px; }
  </style>
<script type="module">
  import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
  import { feature } from "https://cdn.jsdelivr.net/npm/topojson-client@3/+esm";

  // 2:1 aspect to match equirectangular texture
  const width = 960, height = 480;

  const svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

  // A group that will be zoomed/panned
  const mapG = svg.append("g").attr("id", "map");

  // Equirectangular projection to match the texture
  const projection = d3.geoEquirectangular().fitSize([width, height], { type: "Sphere" });
  const path = d3.geoPath(projection);

  // Draw satellite image as background
  mapG.append("image")
    .attr("href", "/static/textures/8k_earth_daymap.jpg")
    .attr("width", width)
    .attr("height", height)
    .attr("preserveAspectRatio", "none"); // assumes 2:1 image (equirectangular)

  // Load and draw country borders on top (no fill)
  const topo = await d3.json("/static/countries-110m.json");
  const countries = feature(topo, topo.objects.countries);

  mapG.selectAll("path.country")
    .data(countries.features)
    .join("path")
    .attr("class", "country")
    .attr("d", path)
    .attr("fill", "none")
    .attr("stroke", "#ffffff")
    .attr("stroke-width", 0.3);

  // Marker for clicks
  const marker = mapG.append("circle")
    .attr("r", 0)
    .attr("fill", "red")
    .attr("opacity", 0.5);


const zoom = d3.zoom()
  .scaleExtent([1, 8])                     // min/max zoom
  .translateExtent([[0, 0], [width, height]]) // keep map within viewport bounds
  .on("zoom", (event) => {
    mapG.attr("transform", event.transform);
    const k = event.transform.k;
    // keep marker dot the same on-screen size
    marker.attr("r", 4 / k);
    // keep impact outline stroke width constant on-screen
    mapG.selectAll(".impact-outline").attr("stroke-width", 2 / k);
  });


  // Attach zoom to the SVG only (UI is a separate fixed div, so it won't move)
  svg.call(zoom);

svg.on("click", async (event) => {
  // Screen-space click
  const [sx, sy] = d3.pointer(event, svg.node());

  // ---- NEW: undo the zoom/pan transform to get map-local coords
  const t = d3.zoomTransform(svg.node());
  const [mx, my] = t.invert([sx, sy]);    // map coordinates before projection

  // Convert to lon/lat
  const [lon, lat] = projection.invert([mx, my]);

  // Move marker in map space (so it scales with zoom)
  marker.attr("cx", mx).attr("cy", my).attr("r", 4);

// Build payload from UI
const payload = {
  lat, lon,
  diameter_m: Number(document.getElementById("diameter_m").value),
  density_kg_m3: Number(document.getElementById("density").value),
  velocity_m_s: Number(document.getElementById("velocity_m_s").value),
  angle_deg: Number(document.getElementById("angle_deg").value),
};

// POST to Flask
const res = await fetch("/api/impact", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(payload)
});
const data = await res.json();
if (data.error) { alert(data.error); return; }


const r = Math.min(120, 10 + 10 * Math.log10(1 + data.E_ground / 1e12));

// Filled disk
mapG.selectAll("circle.impact-fill").data([null]).join("circle")
  .attr("class", "impact-fill")
  .attr("cx", mx).attr("cy", my)
  .attr("r", r)
  .attr("fill", "orange")
  .attr("opacity", 0.25);

// Outline (stroke only) — width is kept constant by the zoom handler
mapG.selectAll("circle.impact-outline").data([null]).join("circle")
  .attr("class", "impact-outline")
  .attr("cx", mx).attr("cy", my)
  .attr("r", r)
  .attr("fill", "none")
  .attr("stroke", "orange")
  .attr("stroke-width", 2)
  .attr("opacity", 0.9);


// Format output as clean multi-line HTML
const out = document.getElementById("out");
out.innerHTML = `
  <table style="border-collapse:collapse;font-size:13px;">
    <tr><td style="padding:2px 6px;"><b>Mass:</b></td><td>${data.mass_kg.toLocaleString(undefined, {maximumFractionDigits:1})} kg</td></tr>
    <tr><td style="padding:2px 6px;"><b>Total Energy:</b></td><td>${(data.E_total/1e12).toFixed(3)} TJ</td></tr>
    <tr><td style="padding:2px 6px;"><b>Atmospheric Loss:</b></td><td>${(data.E_atm_loss/1e12).toFixed(3)} TJ</td></tr>
    <tr><td style="padding:2px 6px;"><b>Ground Impact:</b></td><td>${(data.E_ground/1e12).toFixed(3)} TJ</td></tr>
    <tr><td style="padding:2px 6px;"><b>TNT Equivalent:</b></td><td>${(data.E_ground / 4.184e12).toFixed(2)} kT TNT</td></tr>
  </table>
`;

});

</script>
</head>
<body>
  <div id="ui">
    <strong>Click map to simulate.</strong>
    <label>Diameter (m)</label>
    <input id="diameter_m" type="number" step="1" value="50">
    <label>Density (kg/m³)</label>
    <input id="density" type="number" step="100" value="3000">
    <label>Velocity (m/s)</label>
    <input id="velocity_m_s" type="number" step="100" value="20000">
    <label>Angle (°)</label>
    <input id="angle_deg" type="number" step="1" value="45" min="1" max="89">
    <div id="out" style="margin-top:8px;font-size:12px;color:#444;"></div>
  </div>
</body>
</html>
