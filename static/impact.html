<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Meteor Impact</title>
  <style>
    body { margin:0; font-family: system-ui, sans-serif; }
    #ui { position: fixed; right: 12px; top: 12px; background:#fff; padding:12px; border:1px solid #ddd; border-radius:8px; }
    label { display:block; margin:6px 0 2px; }
    input { width: 180px; }
  </style>
<script type="module">
  import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
  import { feature } from "https://cdn.jsdelivr.net/npm/topojson-client@3/+esm";

  // --- Load NEO data from sessionStorage ---
const neo = JSON.parse(sessionStorage.getItem("neo") || "null");

if (neo) {
  console.log("Loaded NEO data:", neo);

  // Try to pull reasonable values from NASA's NEO JSON
  const approach = neo.close_approach_data?.[0];  // take first close approach
  const velocity = parseFloat(approach?.relative_velocity?.kilometers_per_second || 0);
  const diameter =
    neo.estimated_diameter?.meters?.estimated_diameter_max ||
    neo.estimated_diameter?.meters?.estimated_diameter_min || 50;
  
  // Fill your input boxes if available
  document.getElementById("velocity_m_s").value = (velocity * 1000).toFixed(0); // convert km/s → m/s
  document.getElementById("diameter_m").value = diameter.toFixed(1);
  document.getElementById("density").value = 3000; // default rock density
  document.getElementById("angle_deg").value = 45; // default if unknown
}


  // 2:1 aspect to match equirectangular texture
  const width = 960, height = 480;

  const svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

  // A group that will be zoomed/panned
  const mapG = svg.append("g").attr("id", "map");

  // Equirectangular projection to match the texture
  const projection = d3.geoEquirectangular().fitSize([width, height], { type: "Sphere" });
  const path = d3.geoPath(projection);

  // Draw satellite image as background
  mapG.append("image")
    .attr("href", "/static/textures/8k_earth_daymap.jpg")
    .attr("width", width)
    .attr("height", height)
    .attr("preserveAspectRatio", "none"); // assumes 2:1 image (equirectangular)

  // Load and draw country borders on top (no fill)
  const topo = await d3.json("/static/countries-110m.json");
  const countries = feature(topo, topo.objects.countries);

  mapG.selectAll("path.country")
    .data(countries.features)
    .join("path")
    .attr("class", "country")
    .attr("d", path)
    .attr("fill", "none")
    .attr("stroke", "#ffffff")
    .attr("stroke-width", 0.3);

  // Marker for clicks
  const marker = mapG.append("circle")
    .attr("r", 0)
    .attr("fill", "red")
    .attr("opacity", 0.5);


const zoom = d3.zoom()
  .scaleExtent([1, 8])                     // min/max zoom
  .translateExtent([[0, 0], [width, height]]) // keep map within viewport bounds
  .on("zoom", (event) => {
    mapG.attr("transform", event.transform);
    const k = event.transform.k;
    marker.attr("r", 4 / k); // keep marker dot constant if we ever show it
  });



  // Attach zoom to the SVG only (UI is a separate fixed div, so it won't move)
  svg.call(zoom);

svg.on("click", async (event) => {
  // Screen-space click
  const [sx, sy] = d3.pointer(event, svg.node());

  // ---- NEW: undo the zoom/pan transform to get map-local coords
  const t = d3.zoomTransform(svg.node());
  const [mx, my] = t.invert([sx, sy]);    // map coordinates before projection

  // Convert to lon/lat
  const [lon, lat] = projection.invert([mx, my]);

// Hide marker so we only see the geodesic impact shape
marker.attr("cx", mx).attr("cy", my).attr("r", 0);


mapG.selectAll(".impact-fill, .impact-outline, .impact-core").remove();




// Build payload from UI
const payload = {
  lat, lon,
  diameter_m: Number(document.getElementById("diameter_m").value),
  density_kg_m3: Number(document.getElementById("density").value),
  velocity_m_s: Number(document.getElementById("velocity_m_s").value),
  angle_deg: Number(document.getElementById("angle_deg").value),
};

// POST to Flask
const res = await fetch("/api/impact", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(payload)
});
const data = await res.json();
if (data.error) { alert(data.error); return; }


// 1) Pick a real-world radius from energy (tune this mapping for your demo)
const radiusKm = 50 * Math.log10(1 + data.E_ground / 1e12); // simple demo mapping

// 2) Convert km -> angular degrees on Earth
const radiusDeg = (radiusKm / 6371) * (180 / Math.PI);

// 3) Build a geodesic circle (on the sphere) centered at [lon, lat]
const geoCircle = d3.geoCircle().center([lon, lat]).radius(radiusDeg)(); // returns GeoJSON polygon

// --- Outer damage zone (translucent fill)
mapG.append("path")
  .attr("class", "impact-fill")
  .attr("d", path(geoCircle))
  .attr("fill", "orange")
  .attr("opacity", 0.25)
  .attr("pointer-events", "none")
  .raise();

// --- Outline (constant screen thickness)
mapG.append("path")
  .attr("class", "impact-outline")
  .attr("d", path(geoCircle))
  .attr("fill", "none")
  .attr("stroke", "orange")
  .attr("stroke-width", 2)
  .attr("opacity", 0.9)
  .attr("vector-effect", "non-scaling-stroke")
  .attr("pointer-events", "none")
  .raise();

// --- Inner core zone (dark red, smaller geodesic circle)
const coreRadiusDeg = radiusDeg * 0.45;  // tweak factor as you like
const coreCircle = d3.geoCircle().center([lon, lat]).radius(coreRadiusDeg)();
mapG.append("path")
  .attr("class", "impact-core")
  .attr("d", path(coreCircle))
  .attr("fill", "#7a0d23")
  .attr("opacity", 0.6)
  .attr("pointer-events", "none")
  .raise();






// Format output as clean multi-line HTML
const out = document.getElementById("out");
out.innerHTML = `
  <table style="border-collapse:collapse;font-size:13px;">
    <tr><td style="padding:2px 6px;"><b>Mass:</b></td><td>${data.mass_kg.toLocaleString(undefined, {maximumFractionDigits:1})} kg</td></tr>
    <tr><td style="padding:2px 6px;"><b>Total Energy:</b></td><td>${(data.E_total/1e12).toFixed(3)} TJ</td></tr>
    <tr><td style="padding:2px 6px;"><b>Atmospheric Loss:</b></td><td>${(data.E_atm_loss/1e12).toFixed(3)} TJ</td></tr>
    <tr><td style="padding:2px 6px;"><b>Ground Impact:</b></td><td>${(data.E_ground/1e12).toFixed(3)} TJ</td></tr>
    <tr><td style="padding:2px 6px;"><b>TNT Equivalent:</b></td><td>${(data.E_ground / 4.184e12).toFixed(2)} kT TNT</td></tr>
  </table>
`;

});

</script>
</head>
<body>
  <div id="ui">
    <strong>Click map to simulate.</strong>
    <label>Diameter (m)</label>
    <input id="diameter_m" type="number" step="1" value="50">
    <label>Density (kg/m³)</label>
    <input id="density" type="number" step="100" value="3000">
    <label>Velocity (m/s)</label>
    <input id="velocity_m_s" type="number" step="100" value="20000">
    <label>Angle (°)</label>
    <input id="angle_deg" type="number" step="1" value="45" min="1" max="89">
    <div id="out" style="margin-top:8px;font-size:12px;color:#444;"></div>
  </div>
</body>
</html>
