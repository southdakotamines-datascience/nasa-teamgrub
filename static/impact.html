<!doctype html>
<html>
<head>
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
  <meta charset="utf-8" />
  <title>Meteor Impact</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
    overflow: hidden; /* prevents scrolling */
    font-family: system-ui, sans-serif;
  }
  svg {
    position: absolute;
    top: 0;
    left: 0;
  }
  #ui {
    position: fixed;
    right: 12px;
    top: 12px;
    background: #fff;
    padding: 12px;
    border: 1px solid #ddd;
    border-radius: 8px;
    z-index: 10; /* keep on top of map */
  }
  label { display: block; margin: 6px 0 2px; }
  input { width: 180px; }
</style>
<script type="module">
  import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
  import { feature } from "https://cdn.jsdelivr.net/npm/topojson-client@3/+esm";

  // --- Load NEO data from sessionStorage ---
  const neo = JSON.parse(sessionStorage.getItem("neo") || "null");

  if (neo) {
    console.log("Loaded NEO data:", neo);

    // Try to pull reasonable values from NASA's NEO JSON
    const approach = neo.close_approach_data?.[0];  // take first close approach
    const velocity = parseFloat(approach?.relative_velocity?.kilometers_per_second || 0);
    const diameter = neo.estimated_diameter?.meters?.estimated_diameter_max ||
                     neo.estimated_diameter?.meters?.estimated_diameter_min || 50;
  
    // Fill your input boxes if available
      document.getElementById("velocity_m_s").value = (velocity * 1000).toFixed(0); // convert km/s → m/s
      document.getElementById("diameter_m").value = diameter.toFixed(1);
      document.getElementById("density").value = 3000; // default rock density
      document.getElementById("angle_deg").value = 45; // default if unknown
  }


  // 2:1 aspect to match equirectangular texture
  const width = window.innerWidth;
  const height = window.innerHeight;

  const svg = d3
    .select("body")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  // A fixed-position viewport (centered 2:1 box) + a zoomable group inside it
  const viewG = svg.append("g").attr("id", "viewport");
  const mapG  = viewG.append("g").attr("id", "map");

  // Equirectangular; we'll fit it to the 2:1 box in layout()
  const projection = d3.geoEquirectangular();
  const path = d3.geoPath(projection);

  const earthImg = mapG
    .append("image")
    .attr("href", "/static/textures/8k_earth_daymap.jpg")
    .attr("preserveAspectRatio", "none");

  // Load and draw country borders on top (no fill)
  const topo = await d3.json("/static/countries-110m.json");
  const countries = feature(topo, topo.objects.countries);

  const countriesSel = mapG.selectAll("path.country")
    .data(countries.features)
    .join("path")
    .attr("class", "country")
    .attr("d", path)
    .attr("fill", "none")
    .attr("stroke", "#ffffff")
    .attr("stroke-width", 0.3);

  const zoom = d3.zoom()
    .scaleExtent([1, 8])                     // min/max zoom
    .translateExtent([[0, 0], [width, height]]) // keep map within viewport bounds
    .on("zoom", (event) => {
      mapG.attr("transform", event.transform);
  });

  // Attach zoom to the SVG only (UI is a separate fixed div, so it won't move)
  svg.call(zoom);

  // Globals used by layout() and click handler
  let mapW = 0, mapH = 0, offsetX = 0, offsetY = 0;

  function layout() {
    const W = window.innerWidth, H = window.innerHeight;

    // 1) Largest 2:1 rectangle that fits inside the window
    mapW = W;
    mapH = W / 2;
    if (mapH > H) {                // too tall → base on height
      mapH = H;
      mapW = H * 2;
    }

    // 2) Center that box in the window
    offsetX = (W - mapW) / 2;
    offsetY = (H - mapH) / 2;

    // 3) Resize SVG
    svg.attr("width", W).attr("height", H);

    // 4) Position the viewport group (mapG is inside it)
    viewG.attr("transform", `translate(${offsetX},${offsetY})`);

    // 5) Fit projection to the 2:1 box (NO stretching)
    projection.fitSize([mapW, mapH], { type: "Sphere" });

    // 6) Size the raster image EXACTLY to that box
    earthImg.attr("x", 0).attr("y", 0).attr("width", mapW).attr("height", mapH);

    // 7) Redraw country paths with new projection
    countriesSel.attr("d", path);

    // 8) Keep zoom panning within the 2:1 box
    zoom.translateExtent([[0, 0], [mapW, mapH]]);
}

// Run once and on resize
layout();
window.addEventListener("resize", layout);


svg.on("click", async (event) => {
const [sx, sy] = d3.pointer(event, svg.node());
const t = d3.zoomTransform(svg.node());
// subtract viewport offset, then undo zoom
const [mx, my] = t.invert([sx - offsetX, sy - offsetY]);

// Convert to lon/lat
const [lon, lat] = projection.invert([mx, my]);

mapG.selectAll(".impact-fill, .impact-outline, .impact-core").remove();

// Build payload from UI
const payload = {
  lat, lon,
  diameter_m: Number(document.getElementById("diameter_m").value),
  density_kg_m3: Number(document.getElementById("density").value),
  velocity_m_s: Number(document.getElementById("velocity_m_s").value),
  angle_deg: Number(document.getElementById("angle_deg").value),
};

// POST to Flask
const res = await fetch("/api/impact", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(payload)
});
const data = await res.json();
if (data.error) { alert(data.error); return; }


// --- Better radius model: blast (cube-root) scaling ---
const J_PER_MT = 4.184e15;                 // 1 megaton TNT in Joules
const Y_mt     = data.E_ground / J_PER_MT; // ground-coupled yield (Mt)

// Choose constants (tune to taste):
// R_out ≈ 7 km at 1 Mt for "moderate/visible damage" zone
const K_OUT_KM  = 7.0;
const R_out_km  = K_OUT_KM * Math.cbrt(Math.max(Y_mt, 0));

// Inner “core” (very heavy damage/cratering) ~ 30–50% of outer radius
const CORE_FRACTION = 0.4;
const R_core_km     = CORE_FRACTION * R_out_km;

// Convert to angular degrees on Earth and clamp (avoid wrap-around)
const rad2deg   = 180 / Math.PI;
const R_out_deg  = Math.min(179, (R_out_km  / 6371) * rad2deg);
const R_core_deg = Math.min(179, (R_core_km / 6371) * rad2deg);

// Build geodesic circles centered at [lon, lat]
const outerCircle = d3.geoCircle().center([lon, lat]).radius(R_out_deg)();
const coreCircle  = d3.geoCircle().center([lon, lat]).radius(R_core_deg)();


// --- Outer damage zone (translucent fill)
mapG.append("path")
  .attr("class", "impact-fill")
  .attr("d", path(outerCircle))
  .attr("fill", "orange")
  .attr("opacity", 0.25)
  .attr("pointer-events", "none")
  .raise();

// --- Outline (constant screen thickness)
mapG.append("path")
  .attr("class", "impact-outline")
  .attr("d", path(outerCircle))
  .attr("fill", "none")
  .attr("stroke", "orange")
  .attr("stroke-width", 2)
  .attr("opacity", 0.9)
  .attr("vector-effect", "non-scaling-stroke")
  .attr("pointer-events", "none")
  .raise();

// --- Inner core zone (dark red, smaller geodesic circle)
mapG.append("path")
  .attr("class", "impact-core")
  .attr("d", path(coreCircle))
  .attr("fill", "#7a0d23")
  .attr("opacity", 0.6)
  .attr("pointer-events", "none")
  .raise();


// Format output as clean multi-line HTML
const out = document.getElementById("out");
out.innerHTML = `
  <table style="border-collapse:collapse;font-size:13px;">
    <tr><td style="padding:2px 6px;"><b>Mass:</b></td><td>${data.mass_tons.toLocaleString(undefined, {maximumFractionDigits:0})} tons</td></tr>
    <tr><td style="padding:2px 6px;"><b>Total Energy:</b></td><td>${(data.E_total/1e12).toLocaleString(undefined, { maximumFractionDigits: 0 })} TJ</td></tr>
    <tr><td style="padding:2px 6px;"><b>Atmospheric Loss:</b></td><td>${(data.E_atm_loss/1e12).toLocaleString(undefined, { maximumFractionDigits: 0 })} TJ</td></tr>
    <tr><td style="padding:2px 6px;"><b>Ground Impact:</b></td><td>${(data.E_ground/1e12).toLocaleString(undefined, { maximumFractionDigits: 0 })} TJ</td></tr>
    <tr><td style="padding:2px 6px;"><b>TNT Equivalent:</b></td><td>${(data.E_ground / 4.184e12).toLocaleString(undefined, { maximumFractionDigits: 0 })} kT TNT</td></tr>
  </table>
`;});
</script>
</head>
<body>
  <div id="ui">
    <strong>Click map to simulate.</strong>
    <label>Diameter (m)</label>
    <input id="diameter_m" type="number" step="1" value="50">
    <label>Density (kg/m³)</label>
    <input id="density" type="number" step="100" value="3000">
    <label>Velocity (m/s)</label>
    <input id="velocity_m_s" type="number" step="100" value="20000">
    <label>Angle (°)</label>
    <input id="angle_deg" type="number" step="1" value="45" min="1" max="89">
    <div id="out" style="margin-top:8px;font-size:12px;color:#444;"></div>
  </div>
</body>
</html>
